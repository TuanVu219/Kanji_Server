<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Realtime Drawing Recognizer</title>

<link href="https://fonts.googleapis.com/css2?family=Inter:wght@300..900&display=swap" rel="stylesheet">

<style>
body {
    margin: 0;
    min-height: 100vh;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    background: #1a1a2e;
    color: #e5e5e5;
    font-family: Inter, sans-serif;
}

h2 {
    color: #b2a9e5;
    margin-bottom: 12px;
}

canvas {
    width: 500px;
    height: 400px;
    background: #0d0d18;
    border: 4px solid #b2a9e5;
    border-radius: 12px;
    cursor: crosshair;
    box-shadow: 0 10px 30px rgba(0,0,0,.5);
}

.controls {
    margin-top: 14px;
}

button {
    padding: 10px 22px;
    margin: 0 6px;
    border: none;
    border-radius: 25px;
    background: #b2a9e5;
    color: #1a1a2e;
    font-weight: 700;
    cursor: pointer;
    box-shadow: 0 4px 15px rgba(178,169,229,.4);
}

button:hover {
    background: #9a90d8;
}

#predictions {
    width: 500px;
    margin-top: 20px;
    background: #242442;
    padding: 14px;
    border-radius: 8px;
    font-size: 1em;
}

#predictions div {
    padding: 6px 0;
    border-bottom: 1px dashed #3a3a60;
}

#predictions div:last-child {
    border-bottom: none;
}
</style>
</head>

<body>

<h2>‚ú® Realtime Drawing Recognizer ‚úçÔ∏è</h2>

<canvas id="canvas" width="500" height="400"></canvas>

<div class="controls">
    <button id="undo">‚¨Ö Back</button>
    <button id="clear">üóë Clear</button>
</div>

<div id="predictions">
    <div style="text-align:center;color:#8a8a8a;">B·∫Øt ƒë·∫ßu v·∫Ω ƒë·ªÉ xem d·ª± ƒëo√°n</div>
</div>

<script>
/* =========================
   CANVAS STATE
========================= */
const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");

ctx.lineWidth = 4;
ctx.lineCap = "round";
ctx.strokeStyle = "#40e0d0";

let drawing = false;
let currentStroke = [];
let allStrokes = [];

function clearCanvas() {
    ctx.fillStyle = "#0d0d18";
    ctx.fillRect(0, 0, canvas.width, canvas.height);
}

function redrawCanvas() {
    clearCanvas();
    allStrokes.forEach(stroke => {
        if (stroke.length < 2) return;
        ctx.beginPath();
        ctx.moveTo(stroke[0][0], stroke[0][1]);
        for (let i = 1; i < stroke.length; i++) {
            ctx.lineTo(stroke[i][0], stroke[i][1]);
        }
        ctx.stroke();
        ctx.closePath();
    });
}

clearCanvas();

/* =========================
   WEBSOCKET
========================= */
const scheme = location.protocol === "https:" ? "wss" : "ws";
const ws = new WebSocket(`${scheme}://${location.host}/ws/recognize/`);

ws.onopen = () => console.log("‚úÖ WebSocket connected");

ws.onmessage = (e) => {
    const data = JSON.parse(e.data);
    if (data.status === "predictions") {
        renderPredictions(data.predictions);
    }
};

/* =========================
   DRAW EVENTS
========================= */
canvas.addEventListener("mousedown", e => {
    drawing = true;
    currentStroke = [];

    const r = canvas.getBoundingClientRect();
    const x = e.clientX - r.left;
    const y = e.clientY - r.top;

    ctx.beginPath();
    ctx.moveTo(x, y);
    currentStroke.push([x, y]);
});

canvas.addEventListener("mousemove", e => {
    if (!drawing) return;

    const r = canvas.getBoundingClientRect();
    const x = e.clientX - r.left;
    const y = e.clientY - r.top;

    ctx.lineTo(x, y);
    ctx.stroke();
    currentStroke.push([x, y]);
});

canvas.addEventListener("mouseup", () => {
    if (!drawing) return;
    drawing = false;
    ctx.closePath();

    if (currentStroke.length > 1) {
        allStrokes.push(currentStroke);

        ws.send(JSON.stringify({
            action: "strokes",
            stroke: currentStroke,
            canvas_size: {
                width: canvas.width,
                height: canvas.height
            }
        }));
    }
});

/* =========================
   UNDO
========================= */
document.getElementById("undo").onclick = () => {
    if (allStrokes.length === 0) return;

    allStrokes.pop();
    redrawCanvas();

    ws.send(JSON.stringify({ action: "undo" }));
};

/* =========================
   CLEAR
========================= */
document.getElementById("clear").onclick = () => {
    allStrokes = [];
    clearCanvas();
    ws.send(JSON.stringify({ action: "clear" }));
    document.getElementById("predictions").innerHTML =
        '<div style="text-align:center;color:#8a8a8a;">B·∫Øt ƒë·∫ßu v·∫Ω ƒë·ªÉ xem d·ª± ƒëo√°n</div>';
};

/* =========================
   PREDICTIONS UI (TOP-5)
========================= */
function renderPredictions(predictions) {
    const container = document.getElementById("predictions");
    container.innerHTML = "<b>Top 5 k·∫øt qu·∫£:</b><br/>";

    // 1Ô∏è‚É£ L·∫•y top-5 c·ªßa m·ªói k√Ω t·ª±
    const topKPerChar = predictions.map(p => p.topk.slice(0, 5));

    // 2Ô∏è‚É£ Cartesian product
    function cartesian(arrays) {
        return arrays.reduce((acc, curr) => {
            const res = [];
            acc.forEach(a => {
                curr.forEach(c => {
                    res.push([...a, c]);
                });
            });
            return res;
        }, [[]]);
    }

    const combos = cartesian(topKPerChar);

    // 3Ô∏è‚É£ T√≠nh x√°c su·∫•t chu·ªói
    const scored = combos.map(combo => {
        return {
            text: combo.map(c => c.label).join(""),
            prob: combo.reduce((p, c) => p * c.prob, 1)
        };
    });

    // 4Ô∏è‚É£ Sort & l·∫•y top-5
    scored.sort((a, b) => b.prob - a.prob);
    const top5 = scored.slice(0, 5);

    // 5Ô∏è‚É£ Render
    top5.forEach((c, i) => {
        const div = document.createElement("div");
        div.innerHTML = `
            #${i + 1}: 
            <b style="font-size:18px;color:#40e0d0">${c.text}</b>
            <span style="float:right">
                ${(c.prob * 100).toFixed(2)}%
            </span>
        `;
        container.appendChild(div);
    });
}

</script>

</body>
</html>
